move this:
FS Project

- Setting up app server -> run on terminal "npm init" 
-- fill in the Detailes of the project

- Setup Gitignore with node_modules - so it be problematic later on
-initiating the web server -> run on terminal "npm i express"
--Automatically created - package json

-creating the main app module -> creating app.js file
-Using the express library -> in the app.js, "const express = require('express');"
-- calling it as a function -> in the app.js, "const app = express();"

-creating basic request
--Using the express get functionality -> in app.js, app.get(); 
--- passing the functionality as an arrow callback -> in the function, ('/', (req, res) => {})
----responsing a Hello World -> {res.send('Hello World!);}

-start the web server on a port
--using the express set functionality -> in app.js, app.listen();
--- passing the functionality as an arrow callback -> in the function, (port , () => {})
---Notifying in the terminal for success -> console.log('Yay');

Setting up REST client
-requests file -> create requests.rest file
-- making the former get request through the client -> in requests.rest, GET http://localhost:3001
-- testing -> pressing the Send Request option 

Setting up nodemon for comfortablity refresh
-install nodemon -> npm i --save-dev nodemon 
-updating package json
--running nodemon -> "devstart: nodemon app.js" 

Setting up dotenv for Constants environment
-install env -> npm install dotenv
--file creation -> creating .env file
--defining the port constant -> PORT = 3000

Update - app.listen() function by dotenv update
- reading the constant from dotenv
-- importing the ditenv file -> in app,js, "const dotenv = require('dotenv').config();"
-- creating a local port variable -> "const port = process.env.PORT;"
--- Change the existing port -> from const PORT = 3000; ==> const PORT = process.env.PORT;

Building the Routing Logic
- for checking purposes, we'll expand our backend logic 
--change the get function to be routed to post logic -> change '/' path to '/test'
--adding two get and post functions in the back to app.js
-> app.get('/post', (req, res)) {res.send('app get post')}
-> app.post('/post', (req, res)) {res.send('app post post')}
-- And Update on the front - the REST client requests:
-> Change GET http://localhost:3001 ==> GET http://localhost:3001
--Adding the two client requests
-> GET http://localhost:3001/post
-> POST http://localhost:3001/test















scalabile problems:
-more incoming requests than responses

web server - static pages serving and request handling
-express - web server building
--my_app.get - first response function - the response to recieve
--my_app.listen - opening a port to listen to

app server - app logic handling 
-node js
--file structure
---package.json - project configuration
----name, version, description, author, license, homepage
----scripts
----repository
----bugs
----dependencies
---node-modules - node libraries
---package-lock - version management of dependency versions
--nodemon utility - restarts app after changes are made
--dotenv - parameters configuration

-routing
--pathing to resources - activating functions in the backend
--routing handlers:
---express' router object

Map from the following:
1. 



Playlists To Finish:
- Django tutorial : https://www.youtube.com/watch?v=3EzKBFc9_MQ&list=PL4cUxeGkcC9iqfAag3a_BKEX1N43uJutw&index=14


A handy list (delete later)
node + express + mysql
typescript + nest + nosql
python + django + postgressql
js + react + firebase
java + springboot + postgressql
python + flast + mysql
go + gin + postgressql