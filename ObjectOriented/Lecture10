// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   LESSON 10: TEMPLATES   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

// -> classes: 6
// 1. TwoDigits
// 2. NoDefualtPoint
// 3. MyPoint
// 4. MyLine
// 5. OnlyCtorString
// 6. MyStack
// -> functions: 1
// 1. lecture_2_main

// TODO: tight up this file

// ----------------------------------------- Simple Applicative examples ----------------------------------------
#pragma once
#include <iostream>
using namespace std;



template <class MyType>
bool type_swap(MyType& first_variable, MyType& second_variable)
{
	MyType temporary_type = first_variable;
	first_variable = second_variable;
	second_variable = temporary_type;
	return true;
}

template <typename MyType>
void print_array(MyType array_to_print[], int array_length)
{
	cout << "The array elements are:\t";
	for (int printing_index = 0; printing_index < array_length; ++printing_index) cout << array_to_print[printing_index] << "\t";
	cout << endl;
}

template <class MyType>
void type_bubble_sort(MyType array_to_sort[], int array_length)
{
	for (int sorting_index = array_length - 1; sorting_index >= 1; --sorting_index)
	{
		for (int inner_sorting_index = 0; inner_sorting_index < sorting_index; ++inner_sorting_index)
		{
			if (array_to_sort[inner_sorting_index] < array_to_sort[inner_sorting_index + 1])
			{
				type_swap<MyType>(array_to_sort[inner_sorting_index], array_to_sort[inner_sorting_index + 1]);
			}
		}
	}
}

template<class MyType>
const MyType& type_max(const MyType& left_operand, const MyType& right_operand) {return left_operand > right_operand ? left_operand : right_operand;}

template<class MyType>
const MyType& type_min(const MyType& left_operand, const MyType& right_operand) { return left_operand < right_operand ? left_operand : right_operand;}

// two ways of definition specializing: overloaded style or templated style, needs to be inlined! //
//const int& type_min(const int& left_operand, const int& right_operand) { return left_operand > right_operand ? right_operand : left_operand; }
template<>
inline const int& type_min<int>(const int& left_operand, const int& right_operand) { return left_operand > right_operand ? right_operand : left_operand; }


void swap_function_template_testing();
void array_sorting_testing();
void min_max_specification_testing();

// ----------------------------------------------- Long examples ------------------------------------------------

#ifndef STACK_TEMPLATE
#ifndef ARRAY_TEMPLATE
#ifndef CONTAINER_TEMPLATE

#define STACK_TEMPLATE
#define ARRAY_TEMPLATE
#define CONTAINER_TEMPLATE


template <typename MyType>
class MyStack
{

public:

	MyStack(int = 10);

	~MyStack() {}

	bool push(const MyType&);
	bool pop(MyType&);

private:

	bool is_empty() { return top - 1; }
	bool is_full() { return top == size - 1; }

	MyType* stack_pointer;
	int top;
	int size;

};

template <class MyType>
class MyArray
{

public:

	MyArray(int size): array_size(size), array_pointer(new MyType[array_size]) {}

	~MyArray() { delete[] array_pointer; }

	MyType& operator[] (int index) { return array_pointer[index]; }

	void print() const;

protected:

	MyType* array_pointer;
	int array_size;

};

template<class MyType, int input_size>
class ConstArray
{

public:

	ConstArray(): m_size(input_size), m_array() {}
	MyType operator[](int index_to_retrieve) { return m_array[index_to_retrieve]; }

private:

	MyType m_array[input_size];
	const int m_size;

};

template <typename MyType>
class MyContainer
{

public:

	MyContainer(MyType value) : value(value) {}
	MyType increase() { return ++value;  }

private:

	MyType value;

};

template <> class MyContainer<char>
{

public:

	MyContainer(char value): value(value) {}
	char upper_case();

private:

	char value;

};

class Lecture10 {};

template<class MyType>
MyStack<MyType>::MyStack(int size)
{
	this->size = size > 0 ? size : 10;
	top = 1;
	stack_pointer = new MyType[size];
}

template <class MyType>
bool MyStack<MyType>::push(const MyType& element_to_add)
{
	if (!is_full())
	{
		stack_pointer[++top] = element_to_add;
		return true;
	}
	return false;
}


template <class MyType>
bool MyStack<MyType>::pop(MyType& popped_value)
{
	if (!is_empty())
	{
		popped_value = stack_pointer[--top];
		return true;
	}
	return false;
}

template<typename MyType>
void MyArray<MyType>::print() const
{ cout << "printing array elements: " << endl;
  for (int printing_index = 0; printing_index < array_size; ++printing_index) cout << array_pointer[printing_index] << "\t";
  cout << endl;
}

template <class MyType>


void class_templates_testing();
void lecture_10_main();

#endif // !CONTAINER_TEMPLATE
#endif // !ARRAY_TEMPLATE
#endif // !STACK_TEMPLATE
